# Projet DevOps
## Participants
Elodie JOLO
Remy   SCHERIER


#Déploiement d'une application Flask sur Azure avec Terraform et Kubernetes
##Prérequis

Assurez-vous d'avoir les outils suivants installés sur votre machine :

    - Azure CLI
    - Terraform
    - Docker
    - kubectl

# 1. Déploiement de l'infrastructure Azure avec Terraform

## 1.1. Clonez ce dépôt :

```bash
git clone git@github.com:DrAtsiSama/DevOps.git
```

## 1.2. Exécutez les commandes suivantes dans le répertoire terraform :
```bash
terraform init
terraform apply
```

# 2. Configuration de l'application Flask et création de l'image Docker
```bash
az acr login --name <container-registry-name>
docker build -t your-container-registry.azurecr.io/flask-app:v1 .
docker push your-container-registry.azurecr.io/flask-app:v1
```
<container-registry-name> = acrelo

# 3. Configuration de Kubernetes et déploiement de l'application
## 3.1. Se connecter au cluster kubernetes:
```bash
az aks get-credentials --overwrite-existing -n <cluster name> -g <resource group name>
```
cluster-name = kubernetesCluster
ressource group name = azurerm_resource_group.rg_arg.name = rg-esgi-relo
## 3.2. Appliquez la configuration Kubernetes :
```bash
NAMESPACE=ingress-basic

helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
helm repo update

helm install ingress-nginx ingress-nginx/ingress-nginx \
  --create-namespace \
  --namespace $NAMESPACE \
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path"=/healthz

REGISTRY_NAME=<REGISTRY_NAME>
SOURCE_REGISTRY=registry.k8s.io
CONTROLLER_IMAGE=ingress-nginx/controller
CONTROLLER_TAG=v1.8.1
PATCH_IMAGE=ingress-nginx/kube-webhook-certgen
PATCH_TAG=v20230407
DEFAULTBACKEND_IMAGE=defaultbackend-amd64
DEFAULTBACKEND_TAG=1.5

az acr import --name $REGISTRY_NAME --source $SOURCE_REGISTRY/$CONTROLLER_IMAGE:$CONTROLLER_TAG --image $CONTROLLER_IMAGE:$CONTROLLER_TAG
az acr import --name $REGISTRY_NAME --source $SOURCE_REGISTRY/$PATCH_IMAGE:$PATCH_TAG --image $PATCH_IMAGE:$PATCH_TAG
az acr import --name $REGISTRY_NAME --source $SOURCE_REGISTRY/$DEFAULTBACKEND_IMAGE:$DEFAULTBACKEND_TAG --image $DEFAULTBACKEND_IMAGE:$DEFAULTBACKEND_TAG

# Add the ingress-nginx repository
helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
helm repo update

# Set variable for ACR location to use for pulling images
ACR_URL=<REGISTRY_URL>

# Use Helm to deploy an NGINX ingress controller
helm install ingress-nginx ingress-nginx/ingress-nginx \
    --version 4.7.1 \
    --namespace ingress-basic \
    --create-namespace \
    --set controller.replicaCount=2 \
    --set controller.nodeSelector."kubernetes\.io/os"=linux \
    --set controller.image.registry=$ACR_URL \
    --set controller.image.image=$CONTROLLER_IMAGE \
    --set controller.image.tag=$CONTROLLER_TAG \
    --set controller.image.digest="" \
    --set controller.admissionWebhooks.patch.nodeSelector."kubernetes\.io/os"=linux \
    --set controller.service.loadBalancerIP= <internal-ip> \
    --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-internal"=true \
    --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path"=/healthz \
    --set controller.admissionWebhooks.patch.image.registry=$ACR_URL \
    --set controller.admissionWebhooks.patch.image.image=$PATCH_IMAGE \
    --set controller.admissionWebhooks.patch.image.tag=$PATCH_TAG \
    --set controller.admissionWebhooks.patch.image.digest="" \
    --set defaultBackend.nodeSelector."kubernetes\.io/os"=linux \
    --set defaultBackend.image.registry=$ACR_URL \
    --set defaultBackend.image.image=$DEFAULTBACKEND_IMAGE \
    --set defaultBackend.image.tag=$DEFAULTBACKEND_TAG \
    --set defaultBackend.image.digest=""

#check the load balancer service
kubectl get services --namespace ingress-basic -o wide -w ingress-nginx-controller

kubectl apply -f deployment.yaml
```
REGISTRY_NAME = 
ACR_URL = 
internal-ip = ip in output
# 4. Accès à l'application
```bash
kubectl get svc flask-app
```

# 5. Nettoyage des ressources

Après avoir terminé l'utilisation de vos ressources, il est recommandé de les nettoyer pour éviter des frais inutiles.
```bash
terraform destroy
helm uninstall ingress-nginx --namespace ingress-nginx
kubectl delete -f kubernetes
```
- - - - - - - - - - - - - - - - - - - - - 

## Ecrivez ici les inscriptions et explications pour déployer l'infrastructure et l'application sur Azure
## Introduction
Bonjour et bienvenu dans notre cours sur comment déployer une infrastructure ainsi que l'application sur Azure.
Tout d'abord une petite explication des différentes parties de ce projet.
### Flask-app
La partie "Flask-app" est l'application web développée avec Flask. Elle constitue le cœur de notre projet, fournissant les fonctionnalités principales.
### Kubernetes
Kubernetes est utilisé pour orchestrer et gérer les conteneurs de notre application. Il assure une mise à l'échelle efficace, une gestion des déploiements, et une haute disponibilité.
### Terraform (remy en cours)
Terraform est la pour automatiser la gestion de l'infrastructure sur Azure. Il s'agit d'un outil d'Infrastructure as Code (IaC) permettant une configuration reproductible et évolutive de l'infrastructure cloud.
- terraform init
- terraform plan
- terraform apply -> yes
#### installation


## Instructions de Déploiement
### Prérequis

Avant de commencer le déploiement, assurez-vous d'avoir les éléments suivants :

    Un compte Azure avec les autorisations nécessaires pour créer des ressources.
    Azure CLI installé sur votre machine locale.


## Etapes à suivres
Les différentes parties du projet étant expliquées, nous pouvons désormais nous lancer dans le déployement de notre application.
### Déployer une infrastructure Azure sur Terraform
- cluster kubernetes
- registre docker
### Création d'une image Docker de notre application Flask
- Image Docker
- registry Docker
### Déployer les ressources sur Kubernetes
- flask
- redis
- ingress

### Adresse public
- ressource azurerm_public_ip


### Conclusion

Félicitations, vous avez maintenant déployé avec succès l'infrastructure et l'application sur Azure en utilisant Terraform et Kubernetes.